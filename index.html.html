<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TieSpy </title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');

body {
  margin: 0;
  font-family: 'Poppins', sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  background: radial-gradient(circle at top, #0f2027, #203a43, #2c5364);
  color: #fff;
  height: 100vh;
  padding-top: 20px;
}

h1 {
  font-size: 2em;
  color: #00ffc6;
  text-shadow: 0 0 15px #00ffc6;
  margin-bottom: 10px;
  text-align: center;
}

.controls, .switches {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin-bottom: 15px;
}

button, input[type=range] {
  background: #00ffc6;
  border: none;
  border-radius: 50px;
  padding: 10px 20px;
  color: #003c2d;
  font-weight: 600;
  cursor: pointer;
  transition: 0.2s;
}

button:hover, input[type=range]:hover { transform: scale(1.05); background:#00d6a0; }
button:disabled { opacity: 0.5; cursor: not-allowed; }

.switches label {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: 600;
}

.visual-container {
  width: 90%;
  max-width: 600px;
  position: relative;
}

canvas {
  width: 100%;
  height: 200px;
  background: rgba(255,255,255,0.05);
  border-radius: 12px;
  box-shadow: 0 0 25px rgba(0,255,198,0.2);
}

.volume-bar {
  width: 100%;
  height: 12px;
  background: rgba(255,255,255,0.1);
  border-radius: 6px;
  margin-top: 8px;
  overflow: hidden;
}

.volume-fill {
  width: 0%;
  height: 100%;
  background: linear-gradient(90deg,#00ffc6,#00a3ff);
  transition: width 0.1s linear;
}

#recordTimer { font-size: 1em; color: #00ffc6; margin-top: 5px; text-shadow: 0 0 5px #00ffc6; }
footer { margin-top:auto; font-size:0.9em; opacity:0.6; }
</style>
</head>
<body>

<h1>ðŸŽ§ TieSpy Mobile</h1>

<div class="controls">
  <button id="startBtn">Start</button>
  <button id="stopBtn" disabled>Stop</button>
  <button id="recordBtn" disabled>Record</button>
  <button id="downloadBtn" disabled>Download</button>
  <label>Gain</label>
  <input type="range" id="gainSlider" min="0" max="2" step="0.01" value="1">
</div>

<div class="switches">
  <label><input type="checkbox" id="echoCB" checked>Echo Cancel</label>
  <label><input type="checkbox" id="noiseCB" checked>Noise Suppression</label>
  <label><input type="checkbox" id="autoGainCB" checked>Auto Gain</label>
  <label><input type="checkbox" id="highpassCB" checked>High-pass</label>
  <label><input type="checkbox" id="bandpassCB" checked>Band-pass</label>
  <label><input type="checkbox" id="compressorCB" checked>Compressor</label>
  <label><input type="checkbox" id="waveformCB" checked>Waveform</label>
  <label><input type="checkbox" id="spectrumCB" checked>Spectrum</label>
  <label><input type="checkbox" id="volumeCB" checked>Volume Meter</label>
  <label><input type="checkbox" id="wakeLockCB" checked>Keep Awake</label>
  <label><input type="checkbox" id="timerCB" checked>Recording Timer</label>
</div>

<div class="visual-container">
  <canvas id="visualizer" width="600" height="200"></canvas>
  <div class="volume-bar"><div class="volume-fill" id="volumeFill"></div></div>
  <div id="recordTimer">00:00</div>
</div>

<footer>Dexter's Lab ðŸŒŒ</footer>

<script>
let audioContext, source, analyser, gainNode, dataArray, spectrumArray, stream, recorder, chunks=[];
let animationId, wakeLock=null, seconds=0, recordingInterval=null;

const startBtn=document.getElementById("startBtn");
const stopBtn=document.getElementById("stopBtn");
const recordBtn=document.getElementById("recordBtn");
const downloadBtn=document.getElementById("downloadBtn");
const gainSlider=document.getElementById("gainSlider");
const canvas=document.getElementById("visualizer");
const ctx=canvas.getContext("2d");
const volumeFill=document.getElementById("volumeFill");
const recordTimer=document.getElementById("recordTimer");

// switches
const echoCB=document.getElementById("echoCB");
const noiseCB=document.getElementById("noiseCB");
const autoGainCB=document.getElementById("autoGainCB");
const highpassCB=document.getElementById("highpassCB");
const bandpassCB=document.getElementById("bandpassCB");
const compressorCB=document.getElementById("compressorCB");
const waveformCB=document.getElementById("waveformCB");
const spectrumCB=document.getElementById("spectrumCB");
const volumeCB=document.getElementById("volumeCB");
const wakeLockCB=document.getElementById("wakeLockCB");
const timerCB=document.getElementById("timerCB");

startBtn.onclick=startMonitoring;
stopBtn.onclick=stopMonitoring;
recordBtn.onclick=toggleRecording;
downloadBtn.onclick=downloadRecording;
gainSlider.oninput=()=>{if(gainNode) gainNode.gain.value=parseFloat(gainSlider.value);};

async function startMonitoring(){
  try{
    stream=await navigator.mediaDevices.getUserMedia({audio:{
      echoCancellation:echoCB.checked,
      noiseSuppression:noiseCB.checked,
      autoGainControl:autoGainCB.checked
    }});

    audioContext=new AudioContext();
    await audioContext.resume();

    source=audioContext.createMediaStreamSource(stream);

    let lastNode=source;

    // filters
    if(highpassCB.checked){
      const hp=audioContext.createBiquadFilter();
      hp.type='highpass'; hp.frequency.value=100;
      lastNode.connect(hp); lastNode=hp;
    }

    if(bandpassCB.checked){
      const bp=audioContext.createBiquadFilter();
      bp.type='bandpass'; bp.frequency.value=1000; bp.Q.value=1.5;
      lastNode.connect(bp); lastNode=bp;
    }

    if(compressorCB.checked){
      const comp=audioContext.createDynamicsCompressor();
      comp.threshold.setValueAtTime(-50,audioContext.currentTime);
      comp.knee.setValueAtTime(40,audioContext.currentTime);
      comp.ratio.setValueAtTime(12,audioContext.currentTime);
      comp.attack.setValueAtTime(0.003,audioContext.currentTime);
      comp.release.setValueAtTime(0.25,audioContext.currentTime);
      lastNode.connect(comp); lastNode=comp;
    }

    gainNode=audioContext.createGain();
    gainNode.gain.value=parseFloat(gainSlider.value);
    lastNode.connect(gainNode).connect(audioContext.destination);

    analyser=audioContext.createAnalyser();
    source.connect(analyser);
    analyser.fftSize=2048;
    dataArray=new Uint8Array(analyser.frequencyBinCount);
    spectrumArray=new Uint8Array(analyser.frequencyBinCount);

    recorder=new MediaRecorder(stream);
    recorder.ondataavailable=e=>chunks.push(e.data);
    recorder.onstop=handleRecordingStop;

    if(waveformCB.checked) drawWaveform();
    if(spectrumCB.checked) drawSpectrum();
    if(volumeCB.checked) updateVolume();
    if(wakeLockCB.checked) requestWakeLock();

    startBtn.disabled=true; stopBtn.disabled=false; recordBtn.disabled=false;

  }catch(err){alert("ðŸŽ™ï¸ "+err.message); console.error(err);}
}

function stopMonitoring(){
  if(animationId) cancelAnimationFrame(animationId);
  if(stream) stream.getTracks().forEach(t=>t.stop());
  if(audioContext) audioContext.close();
  releaseWakeLock();
  clearInterval(recordingInterval);
  seconds=0; recordTimer.textContent="00:00";
  startBtn.disabled=false; stopBtn.disabled=true; recordBtn.disabled=true; downloadBtn.disabled=true;
  clearCanvas(); volumeFill.style.width="0%";
}

function drawWaveform(){
  if(!waveformCB.checked) return;
  animationId=requestAnimationFrame(drawWaveform);
  analyser.getByteTimeDomainData(dataArray);
  ctx.fillStyle="rgba(0,0,0,0.2)"; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.lineWidth=2; ctx.strokeStyle="#00ffc6"; ctx.beginPath();
  const sliceWidth=canvas.width/dataArray.length; let x=0;
  for(let i=0;i<dataArray.length;i++){
    const v=dataArray[i]/128; const y=v*canvas.height/2;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); x+=sliceWidth;
  }
  ctx.lineTo(canvas.width,canvas.height/2); ctx.stroke();
}

function drawSpectrum(){
  if(!spectrumCB.checked) return;
  animationId=requestAnimationFrame(drawSpectrum);
  analyser.getByteFrequencyData(spectrumArray);
  const barWidth=canvas.width/spectrumArray.length;
  for(let i=0;i<spectrumArray.length;i++){
    const barHeight=spectrumArray[i]/2;
    ctx.fillStyle="rgba(0,255,198,0.6)"; ctx.fillRect(i*barWidth,canvas.height-barHeight,barWidth,barHeight);
  }
}

function updateVolume(){
  if(!volumeCB.checked) return;
  const buffer=new Uint8Array(analyser.fftSize);
  analyser.getByteTimeDomainData(buffer);
  let sum=0; for(let i=0;i<buffer.length;i++){ const v=(buffer[i]-128)/128; sum+=v*v; }
  const rms=Math.sqrt(sum/buffer.length);
  const volume=Math.min(100,Math.max(0,rms*200));
  volumeFill.style.width=volume+"%";
  requestAnimationFrame(updateVolume);
}

function toggleRecording(){
  if(recorder.state==="inactive"){
    chunks=[]; recorder.start(); recordBtn.textContent="â¹ Stop Rec"; downloadBtn.disabled=true;
    seconds=0; recordTimer.textContent="00:00";
    if(timerCB.checked){
      recordingInterval=setInterval(()=>{
        seconds++; 
        const m=Math.floor(seconds/60).toString().padStart(2,'0');
        const s=(seconds%60).toString().padStart(2,'0');
        recordTimer.textContent=`${m}:${s}`;
      },1000);
    }
  } else { recorder.stop(); recordBtn.textContent="âº Record"; clearInterval(recordingInterval);}
}

function handleRecordingStop(){
  const blob=new Blob(chunks,{type:"audio/webm"});
  const timestamp=new Date().toISOString().replace(/[:.]/g,'-');
  const url=URL.createObjectURL(blob);
  downloadBtn.href=url; downloadBtn.download=`tieSpy_${timestamp}.webm`; downloadBtn.disabled=false;
}

function downloadRecording(){ if(downloadBtn.href){ const link=document.createElement("a"); link.href=downloadBtn.href; link.download=downloadBtn.download; link.click(); } }
function clearCanvas(){ ctx.clearRect(0,0,canvas.width,canvas.height); }

async function requestWakeLock(){
  try{ wakeLock=await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release',()=>console.log('Wake lock released')); } 
  catch(err){console.log(err);}
}
async function releaseWakeLock(){ if(wakeLock){ await wakeLock.release(); wakeLock=null; } }
</script>
</body>
</html>

